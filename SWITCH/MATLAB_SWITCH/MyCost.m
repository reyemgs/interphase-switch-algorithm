%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Расчет значений целевой функции version 1.1                      %
%  Подготовлен в MATLAB 2015                                        %
%  Разработчик: Василий Мохов                                       %
%         email: mokhov_v@mail.ru                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [o] = MyCost(x)

    %% Объявляем используемые глобальные переменные
    global StartSum;           % значения сумм токов по фазам для исходной комбинации
    global StartTHD;           % значения THD по фазам для исходной комбинации
    global col_OP;             % общее количество ОП
    global PreviousV;          % код "предыдущего" лучшего вектора подключений ОП
    global PreviousBest;       % и соответствующее значение целевой функции для него
    global noV;                % длина оптимизируемых бинарных переменных
    global MyConvergenceCurve; % общий массив значений целевой функции
    global allCosts;           % результаты всех вычислений целевой функции

    %% Корректируем расчётный вектор x: заменяем "11" на "как было" у предыдущего лучшего
        for z = 1:2:noV
            if x(z)==1 && x(z+1)==1
                x(z) = PreviousV(z);
                x(z+1) = PreviousV(z+1);
            end
        end

    %% формируем указатель на функцию расчёта суммы токов и THD по фазам
    Sum_THD=@(Vx) Calc_sum_thd(Vx); % Код функциив файле Calc_sum_thd.m

    %% Вычисляем абсолютные значения S, THD и KPOP
    [S, THD_sum_I, KPOP,~,~] = Sum_THD(x);
    % где S - суммы действующих значений токов по фазам
            % корректируем THD, если оно не определено
            THD_sum_I(isnan(THD_sum_I))=[100];

            %% Вычисляем элементы целевой для функции
            [o, F(1,1), F(1,2), ~ ] = Calc_Fitness(S, THD_sum_I, KPOP);
            F(1,3) = KPOP;
            Costs = [allCosts; F];

    %% Обновляем (при "необходимости") лучшее "предыдущее" решение
        if PreviousBest>o    % если новое найденное значение лучше предыдущего
            PreviousBest=o;  % то обновляем его
            PreviousV = x;   % и соответствующий код "предыдущего" лучшего вектора подключений ОП
        end

    %% Добавляем новый элемент в общий массив значений целевой функции
        MyConvergenceCurve = [MyConvergenceCurve, PreviousBest];

    end